[{"content":"前言 サードパーティーライブラリー bwmarrin/discordg\n$ go get github.com/bwmarrin/discordgo  Discord Bot 作成  Go to applications click New Application ボットの名前 Bot -\u0026gt; Add Bot -\u0026gt; Yes, do it! -\u0026gt; Copy TOKEN General Information -\u0026gt; Client ID -\u0026gt; Copy https://discord.com/api/oauth2/authorize?client_id={{Clinet ID}}\u0026amp;permissions=0\u0026amp;scope=bot -\u0026gt; サーバーに追加   コード // main.go package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/bwmarrin/discordgo\u0026#34; ) func main() { // Bot の後ろにスペース \tdiscord, err := discordgo.New(\u0026#34;Bot \u0026#34; + \u0026#34;{{TOKEN}}\u0026#34;) if err != nil { log.Printf(\u0026#34;Create discord bot failed: %v\\n\u0026#34;, err) } // イベントリスト https://discord.com/developers/docs/topics/gateway#commands-and-events-gateway-events \tdiscord.AddHandler(handlers.Ready) discord.AddHandler(handlers.MessageCreate) err = discord.Open() if err != nil { log.Printf(\u0026#34;Open bot failed: %v\\n\u0026#34;, err) } // Wait here until CTRL-C or other term signal is received. \tfmt.Println(\u0026#34;Bot is now running. Press CTRL-C to exit.\u0026#34;) sc := make(chan os.Signal, 1) signal.Notify(sc, syscall.SIGINT, syscall.SIGTERM, os.Interrupt, os.Kill) \u0026lt;-sc // Cleanly close down the Discord session. \tdg.Close() } handler の構成 func MessageCreate(s *discordgo.Session, m *discordgo.\u0026lt;event name\u0026gt;) 簡単の handle // handlers/handlers.go package handlers import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/bwmarrin/discordgo\u0026#34; ) func MessageCreate(s *discordgo.Session, m *discordgo.MessageCreate) { if m.Author.ID == s.State.User.ID { return } fmt.Printf(\u0026#34;%20s %20s %20s \u0026gt; %s\\n\u0026#34;, m.ChannelID, time.Now().Format(time.Stamp), m.Author.Username, m.Content) switch m.Content { //コンテンツが `hello` の時 @author hello \tcase \u0026#34;hello\u0026#34;: s.ChannelMessageSend(m.ChannelID, \u0026#34;\u0026lt;@!\u0026#34;+m.Author.ID+\u0026#34;\u0026gt; hello\u0026#34;) } } func Ready(s *discordgo.Session, m *discordgo.Ready) { // ボットのゲームステータス \ts.UpdateGameStatus(0, \u0026#34;Minecraft\u0026#34;) }  后记 discordgo官方\n","date":"2021-03-14T18:26:02+09:00","image":"https://cdn.jsdelivr.net/gh/zhixuan666/gh-blog@master/images/features/disgo.png","permalink":"https://zhixuan666.github.io/ja/posts/8fa6cc7e/","title":"Golang で Discord ボットを作る"},{"content":"前提 DockerCE は CentOS7 の64ビットバージョンをサポートし、カーネルバージョンが3.10以上である必要があります\nDOCKER公式サイト\n インストール 古いバージョンの docker を削除します $ sudo yum remove docker \\  docker-client \\  docker-client-latest \\  docker-common \\  docker-latest \\  docker-latest-logrotate \\  docker-logrotate \\  docker-engine 新しいバージョンの docker をインストールします $ sudo yum install -y yum-utils $ sudo yum-config-manager \\  --add-repo \\  https://download.docker.com/linux/centos/docker-ce.repo $ sudo yum install docker-ce docker-ce-cli containerd.io ファイアウォールでのポート開放 $ sudo firewall-cmd --permanent --zone=trusted --add-interface=docker0 $ sudo firewall-cmd --reload docker サービスを起動する $ sudo systemctl start docker 自動起動を設定する $ sudo systemctl enable docker  docker ユーザーグループを作成する セキュリティー面を考慮してやるかやらないかの方針決めが必要\ndockerグループはすでにあるはずだけど念の為\n$ sudo groupadd docker 現在のユーザーをdockerグループに入れる\n$ sudo usermod -aG docker $USER 権限の確認 再ログイン後(仮想環境であれば、再起動が必要な場合もある) $ docker run hello-world  docker サービスを再起動起動する。 $ sudo systemctl daemon-reload $ sudo systemctl restart docker  ネットが繋がらない DNS解決エラーかどうかをテストします。\n$ docker run busybox nslookup baidu.com nslookup: write to \u0026#39;127.0.1.1\u0026#39;: Connection refused ;; connection timed out; no servers could be reached DNSエラー\nファイアウォールが有効になっている場合\nDNS 構成ファイル /etc/docker/daemon.json を変更し、DNS サーバーを追加して、 Docker デーモンを再起動します（ファイルが存在しない場合は、新しいファイルを作成してください）\n{ \u0026#34;dns\u0026#34;: [\u0026#34;8.8.8.8\u0026#34;, \u0026#34;1.1.1.1\u0026#34;] }  リンク  🔗docker 🔗daemon.json 説明  ","date":"2020-11-28T18:20:08Z","image":"https://cdn.jsdelivr.net/gh/zhixuan666/gh-blog@master/images/features/docker.png","permalink":"https://zhixuan666.github.io/ja/posts/4064fc4/","title":"CentOS7 に Docker をインストールする方法"},{"content":"はじめに WSL のターミナルは、コピー＆ペーストがし辛く、vscodeで操作できないものかと思い立った。\n WSL (Windows Subsystem for Linux)\n  ssh のインストール $ sudo apt-get remove openssh-server $ sudo apt-get install openssh-server コンフィグ設定 $ sudo vi /etc/ssh/sshd_config コンフィグの内容を下記のように変える。\nPort 22 # デフォルトは問題ありません。占有されているポートがある場合は、自分で変更できます PasswordAuthentication yes # ユーザー名とパスワードによるログインを許可する 補足 ssh サービスを起動する。 $ sudo service ssh restart ssh サービスを終止する。 これで、 ssh クライアントを使用して wsl に接続できます。\nENJOY WSL!\n","date":"2020-11-22T16:41:05Z","image":"https://cdn.jsdelivr.net/gh/zhixuan666/gh-blog@master/images/features/ssh.png","permalink":"https://zhixuan666.github.io/ja/posts/e0320a75/","title":"WSL に SSH で接続する方法"},{"content":"hmac-sha256 署名を検証する func CheckMAC(message, messageMAC, key []byte) bool { mac := hmac.New(sha256.New, key) mac.Write(message) expectedMAC := mac.Sum(nil) return hmac.Equal(messageMAC, expectedMAC) }  ","date":"2020-11-07T22:14:34Z","image":"https://cdn.jsdelivr.net/gh/zhixuan666/gh-blog@master/images/features/3.png","permalink":"https://zhixuan666.github.io/ja/posts/69e3a2bc/","title":"golang hmac-sha256 署名を検証する"},{"content":"初めに  この記事では、全体で root ユーザーを使用して Linux でビルドする方法のみを説明し、使用されるディストリビューションはDebian9.5です。 Ubuntu やその他の Debian ベースの Linux にも適しています。RHELは一部のコマンドのみが異なり、他のコマンドは同じです。\n  Minecraftサーバーを構築 Java と Screen インストール Ubuntuおよびその他のDebianベースのコマンド\n$ sudo apt-get update $ sudo apt-get install java screen -j RHELのコマンド\n$ sudo yum update $ sudo yum install java screen -y サーバーにファイルを保存するためのディレクトリを作成します cd ~ mkdir mcserver cd /mcserver  forge サーバーを構築するには、こちら\n 普通 サーバーを構築する MCversions にアクセスし\n \n必要なバージョンの Server jar を右クリックし、リンクをコピーして、ターミナルへ\n$ wget コピーしたリンクを貼り付けます ダウンロード後、サーバーを起動します。\n$ java -Xms512M -Xmx1024M -jar server.jar -nogui  初めては　EULA ファイルを変更する必要があります\n $ vim eula.txt  eula = false を eula = trueに変更し、コマンドを再入力します。\n  構成ファイルについて\n forge サーバーを構築する MinecraftForge にアクセスし\n \n左がバージョン、真ん中が最新バージョン、右が安定版です。ここから安定版をダウンロードします。\n右クリックし、リンクをコピーして、ターミナルへ\n$ wget コピーしたリンクを貼り付けます $ java -jar forge-*****-install.jar -nogui --installServer インストールを待っていると、 ls　はさらにいくつかのファイルを確認し、次のように入力します。\n$ java -Xms512M -Xmx1024M -jar forge-*****-universal.jar -nogui  初めては　EULA ファイルを変更する必要があります\n $ vim eula.txt  eula = falseをeula = trueに変更し、コマンドを再入力します。\n  modを追加する方法\nダウンロードしたmodをmodsフォルダーに入れて、サーバーを再起動。\n  構成ファイル server.properties enable-command-block=true #コマンドブロックを有効にする query.port=25565 #サーバポート pvp=false #PVPをオフにします ","date":"2020-09-21T21:21:52Z","image":"https://cdn.jsdelivr.net/gh/zhixuan666/gh-blog@master/images/features/minecraft.png","permalink":"https://zhixuan666.github.io/ja/posts/2b678319/","title":"linux Minecraftサーバーを構築"},{"content":"初めに 通常、 Windows Server には RDP 証明書がインポートされていません。接続すると、証明書の警告が表示されます。\n リモート証明書をインストール p12またはpfx形式で証明書をインストール Windows Serverに接続し、証明書をダブルクリックして、[ローカルコンピューター]\u0026gt; [デフォルトのファイル名]\u0026gt; [パスワードとその他の設定のデフォルトを入力]\u0026gt; [すべての証明書を次のストレージに配置-個​​人]\u0026gt; [完了]を選択します。\n \n証明書ハッシュを取得する [Win + R] \u0026gt; [certlm.msc] \u0026gt; [証明書 - ローカルコンピュータ] \u0026gt; [个人] \u0026gt; [証明書] ，インストールした証明書をダブルクリックし、[詳細]\u0026gt; [指紋]を選択します。\n \n \n RDPサービスを構成する Windows Powershell を管理者モードで開き、次のコマンドを実行します。\nwmic /namespace:\\\\root\\cimv2\\TerminalServices PATH Win32_TSGeneralSetting Set SSLCertificateSHA1Hash=\u0026#34;\u0026lt;上記で取得した証明書の指紋\u0026gt;\u0026#34;  \n「属性が正常に更新されました」というプロンプトが表示されます。\n 接続のテスト リモートデスクトップ接続を切断して再接続します。証明書が信頼されていないことを示すものはありません。\n \n サーバー証明書を削除 Win + R \u0026gt; certlm.msc \u0026gt; 証明書 - ローカルコンピュータ \u0026gt; 个人 \u0026gt; 証明書 \u0026gt; 削除\n \n 感謝 \u0026amp; 参考  🔗简单的给远程桌面连接 (Remote Desktop) 配置自定义 SSL 证书  ","date":"2020-09-14T19:02:59Z","image":"https://cdn.jsdelivr.net/gh/zhixuan666/gh-blog@master/images/features/2.jpg","permalink":"https://zhixuan666.github.io/ja/posts/af239327/","title":"Windowsインポートリモート証明書"}]